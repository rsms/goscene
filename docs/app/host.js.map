{
  "version": 3,
  "sources": ["src/host.js"],
  "sourcesContent": ["const log = console.log.bind(console)\n\nfunction assert(cond, msg) {\n  if (DEBUG) { // for DCE\n    if (!cond) {\n      let e = new Error(\"assertion failed: \" + (msg || cond))\n      e.name = \"AssertionError\"\n      throw e\n    }\n  }\n}\n\nfunction int16(n)  { return n << 16 >> 16 }\nfunction uint16(n) { return n & 0xFFFF }\nfunction int32(n)  { return n >> 0 }\nfunction uint32(n) { return n >>> 0 }\n\n// Host call message IDs\nconst HEventSubscribe   = uint32(2)\n    , HEventUnsubscribe = uint32(3)\n    , HWindowSize       = uint32(10)  // () -> i32 (i16x2)\n    , HPixelRatio       = uint32(11)  // () -> f64\n    , HMonotime         = uint32(12)  // () -> f64\n    , HTime             = uint32(13)  // () -> f64\n    , HReadRandom       = uint32(14)  // ([]byte) -> i32\n      // GL (all these functions takes a JS object as the first parameter; context)\n    , HGLdrawingBufferSize = uint32(1000) // () -> i32,i32\n    , HGLcanvasSize = uint32(1001) // () -> i32,i32\n    , HGLviewport = uint32(1002) // (i32,i32,i32,i32) -> ()\n    , HGLclear = uint32(1003) // (u32) -> ()\n    , HGLclearColor = uint32(1004) // (f32,f32,f32,f32) -> ()\n    , HGLclearDepth = uint32(1005) // (f32) -> ()\n    , HGLenable = uint32(1006) // (u32) -> ()\n    , HGLdepthFunc = uint32(1007) // (u32) -> ()\n    , HGLbindBuffer = uint32(1008) // (u32,u32) -> ()\n    , HGLbufferData = uint32(1009) // (u32,u32,u32,[]uint8) -> ()\n    , HGLvertexAttribPointer = uint32(1010)\n    , HGLenableVertexAttribArray = uint32(1011)\n    , HGLuseProgram = uint32(1012)\n    , HGLuniformMatrix2fv = uint32(1013)\n    , HGLuniformMatrix3fv = uint32(1014)\n    , HGLuniformMatrix4fv = uint32(1015)\n    , HGLuniformvf = uint32(1016)\n    , HGLuniformvi = uint32(1017)\n    , HGLdrawArrays = uint32(1018)\n\n// Event IDs\nconst EVNone           = 0\n    , EVWindowResize   = 1 << 0\n    , EVPointerMove    = 1 << 1\n    , EVPointerDown    = 1 << 2\n    , EVPointerUp      = 1 << 3\n    , EVAnimationFrame = 1 << 4\n\nfunction EVString(events) {\n  let names = []\n  if (events & EVWindowResize)   names.push(\"EVWindowResize\")\n  if (events & EVPointerMove)    names.push(\"EVPointerMove\")\n  if (events & EVPointerDown)    names.push(\"EVPointerDown\")\n  if (events & EVPointerUp)      names.push(\"EVPointerUp\")\n  if (events & EVAnimationFrame) names.push(\"EVAnimationFrame\")\n  return names.join(\"|\")\n}\n\n\n// host calls\n// Function name keywords:\n//   i{N}  integer of {N} size\n//   u{N}  unsigned integer of {N} size\n//   f{N}  float of {N} size\n//   v{T}  slice of type {T}\n//   j     JS Object (js.Value in Go.) Load with getJSObject(addr)\n//\n\nconst hostcallHandlers = {}\n\nfunction regHCall(sig, msg, handler) {\n  let v = hostcallHandlers[sig]\n  if (!v) {\n    hostcallHandlers[sig] = v = []\n  }\n  assert(!v[msg], `duplicate hostcall handler ${sig}[${msg}]`)\n  v[msg] = handler\n}\n\n// -----------------------------------------------------------------------------------\n// global\n\n// regHCall(\"vu32_\", HEventSubscribe, (mem, argc, argaddr) => {\n//   let evs = new Array(argc)\n//   let i = 0\n//   for (let endaddr = argaddr + (argc * 4); argaddr < endaddr; argaddr += 4) {\n//     evs[i++] = mem.getUint32(argaddr)\n//   }\n//   host.eventSubscribe(evs)\n// })\n\nregHCall(\"u32_\", HEventSubscribe, (mem, events) => {\n  host.eventSubscribe(events)\n})\n\nregHCall(\"u32_\", HEventUnsubscribe, (mem, events) => {\n  host.eventUnsubscribe(events)\n})\n\n// HPixelRatio: scale of display points to pixels for the current window.\n// A display with 200% scaling factor yields the value 2.0 (i.e. 5dp = 10px.)\nregHCall(\"_f64\", HPixelRatio, () => window.devicePixelRatio || 1.0)\n\n// HMonotime: high-precision monotonic clock (seconds)\nregHCall(\"_f64\", HMonotime, () => performance.now() * 1000)\n\n// HTime: real time in seconds\nconst timeOrigin = Date.now() - performance.now()\nregHCall(\"_f64\", HTime, () => (timeOrigin + performance.now()) * 1000)\n\n// HWindowSize: window size encoded as two uint16.\nregHCall(\"_u32x2\", HWindowSize, () => {\n  return [window.innerWidth, window.innerHeight]\n})\n// // First 16 bits are width, last 16 bits are height.\n// regHCall(\"_i32\", HWindowSize, () => {\n//   return (uint16(window.innerHeight) << 16) | uint16(window.innerWidth)\n// })\n\n// HReadRandom: fills argument array with random bytes. Returns number of bytes filled.\nregHCall(\"vu8_i32\", HReadRandom, (mem, argc, argaddr) => {\n  let data = new Uint8Array(mem.buf, argaddr, argc)\n  return crypto.getRandomValues(data).length\n})\n\nregHCall(\"vi32_i32\", 123, (mem, argc, argaddr) => {\n  log(\"hostcall\", { argaddr, argc })\n  for (let endaddr = argaddr + (argc * 4); argaddr < endaddr; argaddr += 4) {\n    log(`  val#${argc - ((endaddr - argaddr) / 4)}`, mem.getInt32(argaddr))\n  }\n})\n\n// -----------------------------------------------------------------------------------\n// WebGL\nregHCall(\"j_u32x2\", HGLdrawingBufferSize, (mem, gl) =>\n  [ gl.drawingBufferWidth, gl.drawingBufferHeight ]\n)\n\nregHCall(\"j_u32x2\", HGLcanvasSize, (mem, gl) =>\n  [ gl.canvas.clientWidth, gl.canvas.clientHeight ]\n)\n\nregHCall(\"jvi32_\", HGLviewport, (mem, gl, argc, argaddr) => {\n  assert(argc == 4)\n  let x = mem.getInt32(argaddr)\n  let y = mem.getInt32(argaddr + 4)\n  let w = mem.getInt32(argaddr + 8)\n  let h = mem.getInt32(argaddr + 12)\n  gl.viewport(x, y, w, h)\n})\n\nregHCall(\"ju32j_\", HGLbindBuffer, (mem, gl, target, bufferObj) => {\n  gl.bindBuffer(target, bufferObj)\n})\n\nregHCall(\"ju32_\", HGLclear, (mem, gl, mask) => {\n  gl.clear(mask)\n})\n\nregHCall(\"ju32_\", HGLenable, (mem, gl, cap) => {\n  gl.enable(cap)\n})\n\nregHCall(\"ju32_\", HGLdepthFunc, (mem, gl, funcid) => {\n  gl.depthFunc(funcid)\n})\n\nregHCall(\"jvf32_\", HGLclearColor, (mem, gl, argc, argaddr) => {\n  assert(argc == 4)\n  let r = mem.getFloat32(argaddr)\n  let g = mem.getFloat32(argaddr + 4)\n  let b = mem.getFloat32(argaddr + 8)\n  let a = mem.getFloat32(argaddr + 12)\n  gl.clearColor(r, g, b, a)\n})\n\nregHCall(\"jf32_\", HGLclearDepth, (mem, gl, d) => {\n  gl.clearDepth(d)\n})\n\nregHCall(\"jvu32_\", HGLbufferData, (mem, gl, argc, argaddr) => {\n  // Note: bufferData accepts a variety of data types. Rather than implementing\n  // separate handlers for each possible data type, we instead accept a pointer to data\n  // including the size in bytes of that data in memory. Then, we provide gl.bufferData\n  // with a view into Go memory where the data is stored.\n  //\n  // Note: We can not avoid allocating a JS object here (the Uint8Array).\n  // WebGL2 adds two additional arguments to bufferData\u2014srcOffset, length\u2014that allows\n  // passing in an existing ArrayBuffer and have the API read a range. If this code is\n  // ever converted or ported to WebGL2, keep that in mind.\n  assert(argc == 4)\n  const target   = mem.getUint32(argaddr)\n  const usage    = mem.getUint32(argaddr + 4)\n  const dataaddr = mem.getUint32(argaddr + 8)   // address of data in gomem\n  const datasize = mem.getUint32(argaddr + 12)  // size of data in bytes\n  gl.bufferData(target, new Uint8Array(mem.buf, dataaddr, datasize), usage)\n})\n\nregHCall(\"jvu32_\", HGLvertexAttribPointer, (mem, gl, argc, argaddr) => {\n  assert(argc == 6)\n  const index      = mem.getUint32(argaddr)\n  const size       = mem.getUint32(argaddr + 4)\n  const type       = mem.getUint32(argaddr + 8)\n  const normalized = mem.getUint32(argaddr + 12)\n  const stride     = mem.getUint32(argaddr + 16)\n  const offset     = mem.getUint32(argaddr + 20)\n  gl.vertexAttribPointer(index, size, type, normalized, stride, offset)\n})\n\nregHCall(\"ju32x3_\", HGLdrawArrays, (mem, gl, mode, first, count) => {\n  gl.drawArrays(mode, first, count)\n})\n\nfor (let [size,msg] of [[2,HGLuniformMatrix2fv],[3,HGLuniformMatrix3fv],[4,HGLuniformMatrix4fv]]) {\n  const f = WebGLRenderingContext.prototype[`uniformMatrix${size}fv`]\n  const count = size * size\n  regHCall(\"jx2vu32_\", msg, (mem, gl, location, argc, argaddr) => {\n    assert(argc == 2)\n    const transpose  = mem.getUint32(argaddr)\n    const ptr        = mem.getUint32(argaddr + 4)\n    const value      = new Float32Array(mem.buf, ptr, count)\n    f.call(gl, location, transpose, value)\n  })\n}\n\nregHCall(\"jx2vf32_\", HGLuniformvf, (mem, gl, location, argc, argaddr) => {\n  if (argc == 1) {\n    gl.uniform1f(location, mem.getFloat32(argaddr))\n  } else {\n    const values = new Float32Array(mem.buf, argaddr, argc)\n    if (argc == 2) {\n      gl.uniform2fv(location, values)\n    } else if (argc == 3) {\n      gl.uniform3fv(location, values)\n    } else if (argc == 4) {\n      gl.uniform4fv(location, values)\n    } else {\n      throw new Error(`invalid value count ${argc}`)\n    }\n  }\n})\n\nregHCall(\"jx2vi32_\", HGLuniformvi, (mem, gl, location, argc, argaddr) => {\n  if (argc == 1) {\n    gl.uniform1i(location, mem.getInt32(argaddr))\n  } else {\n    const values = new Int32Array(mem.buf, argaddr, argc)\n    if (argc == 2) {\n      gl.uniform2iv(location, values)\n    } else if (argc == 3) {\n      gl.uniform3iv(location, values)\n    } else if (argc == 4) {\n      gl.uniform4iv(location, values)\n    } else {\n      throw new Error(`invalid value count ${argc}`)\n    }\n  }\n})\n\nregHCall(\"ju32_\", HGLenableVertexAttribArray, (mem, gl, index) => {\n  gl.enableVertexAttribArray(index)\n})\n\nregHCall(\"jx2_\", HGLuseProgram, (mem, gl, program) => {\n  gl.useProgram(program)\n})\n\n\n// -----------------------------------------------------------------------------------\n// Go memory interface\nclass GoMemory {\n  constructor(go) {\n    this.go = go\n    this.buf = null   // ArrayBuffer\n    this.view = null  // DataView\n    this.version = 0  // increments when this.buf is replaced\n  }\n\n  check() {\n    let buf = this.go._inst.exports.mem.buffer\n    if (this.buf !== buf) {\n      // WASM memory changed\n      this.buf = buf\n      this.view = new DataView(buf)\n      this.version++\n    }\n    return this\n  }\n\n  getInt8(addr) { return this.view.getInt8(addr, true) }\n  getUint8(addr) { return this.view.getUint8(addr, true) }\n  getInt16(addr) { return this.view.getInt16(addr, true) }\n  getUint16(addr) { return this.view.getUint16(addr, true) }\n  getInt32(addr) { return this.view.getInt32(addr, true) }\n  getUint32(addr) { return this.view.getUint32(addr, true) }\n  getFloat32(addr) { return this.view.getFloat32(addr, true) }\n  getFloat64(addr) { return this.view.getFloat64(addr, true) }\n  getBigInt64(addr) { return this.view.getBigInt64(addr, true) }\n  getBigUint64(addr) { return this.view.getBigUint64(addr, true) }\n\n  setInt8(addr, v) { return this.view.setInt8(addr, v, true) }\n  setUint8(addr, v) { return this.view.setUint8(addr, v, true) }\n  setInt16(addr, v) { return this.view.setInt16(addr, v, true) }\n  setUint16(addr, v) { return this.view.setUint16(addr, v, true) }\n  setInt32(addr, v) { return this.view.setInt32(addr, v, true) }\n  setUint32(addr, v) { return this.view.setUint32(addr, v, true) }\n  setFloat32(addr, v) { return this.view.setFloat32(addr, v, true) }\n  setFloat64(addr, v) { return this.view.setFloat64(addr, v, true) }\n  setBigInt64(addr, v) { return this.view.setBigInt64(addr, v, true) }\n  setBigUint64(addr, v) { return this.view.setBigUint64(addr, v, true) }\n\n  getInt64(addr) {\n    const low = this.view.getUint32(addr + 0, true)\n    const high = this.view.getInt32(addr + 4, true)\n    return low + high * 4294967296\n  }\n\n  setInt64(addr, v) {\n    this.view.setUint32(addr + 0, v, true)\n    this.view.setUint32(addr + 4, Math.floor(v / 4294967296), true)\n  }\n\n  getUint8Slice(addr) {\n    const arrayAddr = this.getInt64(addr)\n    const len = this.getInt64(addr + 8)\n    return new Uint8Array(this.buf, arrayAddr, len)\n  }\n\n  getInt32Slice(addr) {\n    const arrayAddr = this.getInt64(addr)\n    const len = this.getInt64(addr + 8)\n    return new Int32Array(this.buf, arrayAddr, len)\n  }\n\n  getJSObject(addr) {\n    const id = this.getUint32(addr)\n    return this.go._values[id]\n  }\n}\n\n// -----------------------------------------------------------------------------------\n\nconst host = new class Host {\n  constructor() {\n    this.copyBuffer = new ArrayBuffer(4096)\n    this.copyBufferU8 = new Uint8Array(this.copyBuffer)\n    this.copyBufferF32 = new Float32Array(this.copyBuffer)\n\n    this.eventMsgBuf  = new ArrayBuffer(4096)\n    this.eventMsgView = new DataView(this.eventMsgBuf)\n\n    this.wasmInstance = null\n\n    this.eventSubMask = 0      // subscribed events (bitmask)\n    this.eventQueueMask = 0    // queued events\n    this.eventData = new Map() // queued event data keyed by event\n\n    // container holding all current persistent events\n    this.persistentEvents = new Map()\n    this.persistentEventsVersion = 0  // increments when persistentEvents changes\n\n    // map of persistent events, ORd with this.eventQueueMask\n    this.persistentEventMask = 0\n\n    this.runloopTickFunc = null\n\n\n    let go = this.go = new Go()\n    let gomem = new GoMemory(go)\n    this.gomem = gomem\n\n    function bindHostcall(sigs, handler) {\n      if (!Array.isArray(sigs)) {\n        sigs = [ sigs ]\n      }\n      for (let sig of sigs) {\n        const impl = hostcallHandlers[sig]\n        assert(impl, `no hostcallHandlers[sig=${sig}]`)\n        delete hostcallHandlers[sig]\n        go.importObject.go[\"main.hostcall_\" + sig] = sp => {\n          const mem = gomem.check()\n          const msg = mem.getInt32(sp + 8)\n          const f = impl[msg]\n          if (!f) { throw new Error(`invalid hostcall_${sig} #${msg}`) }\n          sp += 16\n          handler(mem, sp, f)\n        }\n      }\n    }\n\n    bindHostcall(\"_f64\", (mem, sp, f) => {\n      mem.setFloat64(sp, f(mem))\n    })\n\n    bindHostcall(\"_u32x2\", (mem, sp, f) => {\n      const result = f(mem)\n      mem.setUint32(sp, result[0])\n      mem.setUint32(sp + 4, result[1])\n    })\n\n    bindHostcall([\"vu8_i32\",\"vi32_i32\"], (mem, sp, f) => {\n      const argaddr = mem.getInt64(sp)\n      const argcount = mem.getInt64(sp + 8)\n      const result = f(mem, argcount, argaddr)\n      mem.setInt32(sp + 24, result)\n    })\n\n    // bindHostcall([\"vu32_\"], (mem, sp, f) => {\n    //   const argaddr = mem.getInt64(sp)\n    //   const argcount = mem.getInt64(sp + 8)\n    //   f(mem, argcount, argaddr)\n    // })\n\n    bindHostcall(\"j_u32x2\", (mem, sp, f) => {\n      const obj1 = mem.getJSObject(sp)\n      const result = f(mem, obj1)\n      mem.setUint32(sp + 8, result[0])\n      mem.setUint32(sp + 12, result[1])\n    })\n\n    bindHostcall([\"jvi32_\", \"jvu32_\", \"jvf32_\"], (mem, sp, f) => {\n      const obj1 = mem.getJSObject(sp)\n      const argaddr = mem.getInt64(sp + 8)\n      const argcount = mem.getInt64(sp + 16)\n      f(mem, obj1, argcount, argaddr)\n    })\n\n    bindHostcall(\"ju32x3_\", (mem, sp, f) => {\n      const obj1 = mem.getJSObject(sp)\n      const v1 = mem.getUint32(sp + 8)\n      const v2 = mem.getUint32(sp + 12)\n      const v3 = mem.getUint32(sp + 16)\n      f(mem, obj1, v1, v2, v3)\n    })\n\n    bindHostcall([\"jx2vi32_\", \"jx2vu32_\", \"jx2vf32_\"], (mem, sp, f) => {\n      const obj1 = mem.getJSObject(sp)\n      const obj2 = mem.getJSObject(sp + 8)\n      const argaddr = mem.getInt64(sp + 16)\n      const argcount = mem.getInt64(sp + 24)\n      f(mem, obj1, obj2, argcount, argaddr)\n    })\n\n    bindHostcall(\"ju32_\", (mem, sp, f) => {\n      f(mem, mem.getJSObject(sp), mem.getUint32(sp + 8))\n    })\n\n    bindHostcall(\"jf32_\", (mem, sp, f) => {\n      f(mem, mem.getJSObject(sp), mem.getFloat32(sp + 8))\n    })\n\n    bindHostcall(\"ju32j_\", (mem, sp, f) => {\n      f(mem, mem.getJSObject(sp), mem.getUint32(sp + 8), mem.getJSObject(sp + 16))\n    })\n\n    bindHostcall(\"jx2_\", (mem, sp, f) => {\n      f(mem, mem.getJSObject(sp), mem.getJSObject(sp + 8))\n    })\n\n    bindHostcall(\"u32_\", (mem, sp, f) => {\n      f(mem, mem.getUint32(sp - 4)) // -4 wtf\n    })\n\n    // check to make sure all hostcall handlers were bound\n    if (DEBUG) {\n      for (let _ in hostcallHandlers) {\n        throw new Error(\n          `not all hostcallHandlers were bound with bindHostcall.\\n` +\n          `Unhandled signatures:\\n  ` +\n          Object.keys(hostcallHandlers).join('\\n  ') + \"\\n\"\n        )\n      }\n    }\n\n    this.initEvents() // XXX\n  }\n\n  log() {\n    console.log.apply(console, arguments)\n  }\n\n  error(err) {\n    console.error(typeof err == \"object\" && err.stack ? err.stack : String(err))\n  }\n\n  get windowWidth() { return window.innerWidth }\n  get windowHeight() { return window.innerHeight }\n\n  get onWindowResize() { return null }\n  set onWindowResize(f) {\n    window.addEventListener(\"resize\", f)\n  }\n\n  get onPointerMove() { return null }\n  set onPointerMove(f) {\n    window.addEventListener(\"pointermove\", f)\n  }\n\n  get pixelScale() { return window.devicePixelRatio || 1 }\n\n  monotime() {\n    // Go does not export a monotonic timer, even though runtime.nanotime() in WASM is backed\n    // by performance.now() (but it's internal and not exposed in Go.)\n    return performance.now()\n  }\n\n  getContext(canvas, contextType) {\n    return canvas.getContext(contextType)\n    // let g = canvas.getContext(contextType)\n    // // log(`canvas.getContext(${contextType}) =>`, g)\n    // // must wrap and bind all members to make go's js/Invoke() work\n    // let g2 = { __proto__:g }\n    // for (let k in g) {\n    //   let v = g[k]\n    //   if (typeof v == \"function\") {\n    //     g2[k] = v.bind(g)\n    //   } else {\n    //     Object.defineProperty(g2, k, {\n    //       get() { return g[k] },\n    //       set(v) { g[k] = v },\n    //       enumerable: true,\n    //     })\n    //   }\n    // }\n    // return g2\n  }\n\n  // main() :Promise<void>\n  main(wasmInstance) {\n    // log(\"Host.main() wasm exports:\")\n    // for (let k in wasmInstance.exports) {\n    //   log(`  ${k}`, wasmInstance.exports[k])\n    // }\n    this.wasmInstance = wasmInstance\n    return this.go.run(wasmInstance) // Promise<void> resolved when main() exits\n  }\n\n  initEvents() {\n    const h = this\n\n    const jsEvent = (obj, name, handler) => ({\n      ev: 0,\n      _jsevent: true,\n      handler,\n      enable() { obj.addEventListener(name, this.handler) },\n      disable() { obj.removeEventListener(name, this.handler) },\n    })\n\n    const persistentEvent = (ev, data) => ({\n      ev,\n      enable() { h.enablePersistentEvent(ev, data) },\n      disable() { h.disablePersistentEvent(ev) },\n    })\n\n    // handlePointerEvent translates a PointerEvent into data that is sent to WASM.\n    // Note: Changing this requires changes to host.go\n    const handlePointerEvent = ev => [ ev.pointerId, ev.x*10, ev.y*10, ev.buttons ]\n\n    // all supported events\n    h.events = {\n      [EVPointerMove]:  jsEvent(window, \"pointermove\", handlePointerEvent),\n      [EVPointerDown]:  jsEvent(window, \"pointerdown\", handlePointerEvent),\n      [EVPointerUp]:    jsEvent(window, \"pointerup\",   handlePointerEvent),\n      [EVWindowResize]: jsEvent(window, \"resize\", ev => [window.innerWidth, window.innerHeight] ),\n\n      [EVAnimationFrame]: persistentEvent(EVAnimationFrame),\n    }\n    for (let k in h.events) {\n      let e = h.events[k]\n      let ev = e.ev = parseInt(k)\n      if (e._jsevent) {\n        let handler = e.handler\n        e.handler = (jsevent) => {\n          h.eventEnqueue(ev, handler(jsevent))\n        }\n      }\n    }\n  }\n\n  eventSubscribe(events) {\n    log(\"host.eventSubscribe\", events, EVString(events))\n    for (let k in this.events) {\n      let e = this.events[k]\n      if (events & e.ev && (this.eventSubMask & e.ev) == 0) {\n        e.enable()\n      }\n    }\n    this.eventSubMask |= events\n  }\n\n  eventUnsubscribe(events) {\n    log(\"host.eventUnsubscribe\", events, EVString(events))\n    for (let e of this.events) {\n      if (events & e.ev && this.eventSubMask & e.ev) {\n        e.disable()\n        this.eventData.delete(e.ev)\n      }\n    }\n    this.eventQueueMask |= ~events\n    this.eventSubMask |= ~events\n  }\n\n  eventEnqueue(ev, data) {\n    // log(`eventEnqueue ${EVString(ev)}`, data)\n    assert(!data || data instanceof Array)\n    this.eventQueueMask |= ev\n    this.eventData.set(ev, data)\n    if (this.runloopWake) {\n      this.runloopWakeA()\n    }\n  }\n\n  enablePersistentEvent(ev, data) {\n    this.persistentEventMask |= ev\n    this.eventQueueMask |= ev\n    this.persistentEvents.set(ev, data)\n    this.persistentEventsVersion++\n    if (this.runloopWake) {\n      this.runloopWake()\n    }\n  }\n\n  disablePersistentEvent(ev) {\n    this.persistentEventMask |= ~ev\n    this.eventQueueMask |= ev\n    this.persistentEvents.delete(ev)\n    this.persistentEventsVersion++\n  }\n\n  stopRunLoop() {\n    log(\"Host.stopRunLoop\")\n    this.runloopTickFunc = null\n  }\n\n  startRunLoop(gocb, msgbufaddr, msgbufsize) {\n    // Go caller provides a memory segment at msgbufaddr of msgbufsize size in bytes\n    // where we write and read input and output data.\n    //\n    // Example\n    // this.eventEnqueue(EVPointerMove, [123, 456])\n    // this.eventEnqueue(EVPointerDown, [700, 800])\n    //\n    // uint32 data written to gomem:\n    //  0  3     EVENT_MASK\n    //  1  2     EVENT_COUNT\n    //  2  2     event# EVPointerMove\n    //  3  2     len(event_data) = 2\n    //  4  123   event_data[0]\n    //  5  456   event_data[1]\n    //  6  3     event# EVPointerDown\n    //  7  2     len(event_data) = 2\n    //  8  700   event_data[0]\n    //  9  800   event_data[1]\n    log(\"Host.startRunLoop\")\n    if (this.runloopTickFunc) {\n      throw new Error(\"runloop already running\")\n    }\n\n    const timeOrigin = performance.now()\n\n    // address/offset into gomem\n    let a = msgbufaddr\n    const TIME        = a ; a += 4\n    const EVENT_MASK  = a ; a += 4\n    const EVENT_COUNT = a ; a += 4\n    const EVENT_DATA  = a // until msgbufaddr + msgbufsize\n\n    // number of p. events written in gomem. This needs to be tracked separately from\n    // this.persistentEvents.size as this.persistentEvents may change while we write\n    // event data to gomem\n    let persistentEventInMemCount = 0\n\n    // address in gomem where transient event data start (after persistent data)\n    let transientEventDataAddr = 0\n\n    // writes all persistent events to memory\n    const writePersistentEvents = (mem) => {\n      let addr = EVENT_DATA\n      for (let [ev, data] of this.persistentEvents) {\n        addr = writeEventData(mem, addr, ev, data)\n      }\n      // transient events follows persistent events in memory\n      persistentEventInMemCount = this.persistentEvents.size\n      transientEventDataAddr = addr\n    }\n\n    // Writes event and its optional data to mem at addr. Returns adjusted addr.\n    const writeEventData = (mem, addr, ev, data) => {\n      mem.setUint32(addr, ev) ; addr += 4\n      mem.setUint32(addr, data ? data.length : 0) ; addr += 4\n      if (data) for (let v of data) {\n        mem.setUint32(addr, v) ; addr += 4\n      }\n      return addr\n    }\n\n    // memVersion is compared to gomem.version to discover when gomem was either\n    // found initially or relocated.\n    let memVersion = 0\n\n    // tracks dirty state of this.persistentEvents by comparing to this.persistentEventsVersion\n    let persistentEventsVersion = 0\n\n    var tick = () => {\n      if (this.runloopTickFunc !== tick) {\n        // runloop stopped or restarted with different tick function\n        return\n      }\n\n      let mem = this.gomem.check()\n\n      if (mem.version != memVersion) {\n        // gomem initialized or relocated\n        writePersistentEvents(mem)\n        memVersion = mem.version\n        persistentEventsVersion = this.persistentEventsVersion\n      } else if (this.persistentEventsVersion != persistentEventsVersion) {\n        // persistent events changed\n        persistentEventsVersion = this.persistentEventsVersion\n        writePersistentEvents(mem)\n      }\n\n      // write input\n      mem.setFloat32(TIME, (performance.now() - timeOrigin) / 1000)\n      mem.setUint32(EVENT_MASK, this.eventQueueMask)\n      mem.setUint32(EVENT_COUNT, persistentEventInMemCount + this.eventData.size)\n\n      // write transient events\n      if (this.eventData.size > 0) {\n        let addr = transientEventDataAddr\n        for (let [ev, data] of this.eventData) {\n          addr = writeEventData(mem, addr, ev, data)\n        }\n        // reset (in case gocb sets new events)\n        this.eventQueueMask = this.eventQueueMask & this.persistentEventMask\n        this.eventData.clear()\n      }\n\n      // reset wake signal\n      this.runloopWake = null\n\n      // call into go\n      gocb()\n\n      if (this.eventQueueMask != 0) {\n        // there are still events queued\n        requestAnimationFrame(tick)\n      } else {\n        this.runloopWake = tick\n      }\n    }\n\n    this.runloopWakeA = () => {\n      this.runloopWake = null\n      requestAnimationFrame(tick)\n    }\n\n    this.runloopTickFunc = tick\n    tick()\n  }\n}\n\n\n// tear off initialization data from the global object\nconst appinit = window[\"_appinit\"]\nlet wasmStartTime = 0\nappinit[\"host\"] = host\nappinit[\"initCallback\"] = () => {\n  // called when the wasm program deems itself initialized\n  const wasmTime = (performance.now() - wasmStartTime).toFixed(1)\n  console.debug(`wasm initialized in ${wasmTime}ms`)\n  delete window[\"_appinit\"]\n  if (appinit.onLoaded) { appinit.onLoaded() }\n}\nconsole.debug(`host boot ${Date.now()-appinit.time}ms`)\n\n// load, instantiate and run wasm module\n;(WebAssembly.instantiateStreaming ?\n  WebAssembly.instantiateStreaming(appinit.wasmFetch, host.go.importObject) :\n  appinit.wasmFetch.then(r => r.arrayBuffer()).then(buf =>\n    WebAssembly.instantiate(buf, host.go.importObject))\n).then(m => {\n  wasmStartTime = performance.now()\n  host.main(m.instance)\n})\n"],
  "mappings": "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",
  "names": []
}
